<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat Application</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .main-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        h2 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }

        h3 {
            color: #764ba2;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .peer-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .peer-info p {
            margin: 5px 0;
            font-size: 14px;
        }

        .peer-info strong {
            color: #667eea;
        }

        .peer-list, .connected-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .peer-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }

        .peer-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .peer-item-info {
            font-size: 13px;
        }

        .peer-item-info .peer-address {
            font-weight: bold;
            color: #333;
        }

        .peer-item-info .peer-status {
            color: #28a745;
            font-size: 11px;
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .btn-connect {
            background: #667eea;
            color: white;
        }

        .btn-connect:hover {
            background: #5568d3;
        }

        .btn-connect:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* ================== S·ª¨A ƒê·ªîI CSS ================== */
        /* X√≥a style c≈© c·ªßa .connected-item */
        .connected-item {
            /* ... style c≈© b·ªã x√≥a ... */
        }
        .connected-item::before {
            /* ... style c≈© b·ªã x√≥a ... */
        }
        
        /* Style m·ªõi cho c√°c n√∫t b·∫•m peer */
        .connected-item-button {
            background: #d4edda;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: #155724;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .connected-item-button:hover {
            border-color: #28a745;
            background: #c3e6cb;
            transform: scale(1.02);
        }
        /* =============================================== */


        .channel-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .channel-tab {
            padding: 8px 16px;
            background: #e9ecef;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            position: relative;
        }

        .channel-tab.active {
            background: #667eea;
            color: white;
        }

        .channel-tab.joined {
            background: #28a745;
            color: white;
        }

        .channel-tab.joined.active {
            background: #667eea;
        }

        .channel-tab:hover {
            background: #764ba2;
            color: white;
        }
        
        /* ================== S·ª¨A ƒê·ªîI CSS ================== */
        /* Style m·ªõi cho c√°c tab chat 1:1 */
        .channel-tab.p2p {
            background: #e2f0ff;
            color: #004085;
            border: 1px solid #b8daff;
        }
        
        .channel-tab.p2p.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        /* =============================================== */


        .channel-tab .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            padding: 10px 15px;
            border-radius: 8px;
            max-width: 70%;
            word-wrap: break-word;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.received {
            background: white;
            border-left: 3px solid #667eea;
            align-self: flex-start;
        }

        .message.sent {
            background: #667eea;
            color: white;
            align-self: flex-end;
        }

        .message .sender {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .message .content {
            font-size: 14px;
        }

        .message .time {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .input-area {
            display: flex;
            gap: 10px;
        }

        .input-area input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-area input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-send {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-send:hover {
            background: #5568d3;
            transform: scale(1.05);
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .config-section {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }

        .config-section input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .btn-init {
            width: 100%;
            padding: 10px;
            background: #ffc107;
            color: #333;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }

        .btn-init:hover {
            background: #e0a800;
        }

        .channel-join-prompt {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .channel-join-prompt button {
            margin-top: 15px;
            padding: 10px 24px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .channel-join-prompt button:hover {
            background: #218838;
        }

        /* Notification System */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            gap: 12px;
            align-items: flex-start;
            animation: slideInRight 0.3s ease, fadeOut 0.3s ease 4.7s;
            border-left: 4px solid #667eea;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        .notification.success {
            border-left-color: #28a745;
        }
        
        /* ƒê·ªïi 'info' trong CSS ƒë·ªÉ kh·ªõp v·ªõi code (t·ª´ 'info' th√†nh 'info') */
        .notification.info {
            border-left-color: #17a2b8;
        }

        .notification.warning {
            border-left-color: #ffc107;
        }
        
        .notification.error { /* Th√™m error type */
            border-left-color: #dc3545;
        }

        .notification-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .notification-content {
            flex: 1;
        }

        .notification-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
            color: #333;
        }

        .notification-message {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .notification-time {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }

        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            color: #333;
        }
    </style>
</head>
<body>
    <!-- Notification Container -->
    <div class="notification-container" id="notificationContainer"></div>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Configuration -->
            <div class="config-section">
                <h3>‚öôÔ∏è Configuration</h3>
                <p style="font-size: 12px; color: #666; margin-bottom: 10px;">
                    Auto-detected from URL. Adjust if needed.
                </p>
                <input type="text" id="myIp" placeholder="My IP" readonly style="background: #f0f0f0;">
                <input type="number" id="myPort" placeholder="My Port" readonly style="background: #f0f0f0;">
                <input type="text" id="trackerIp" placeholder="Tracker IP" value="127.0.0.1">
                <input type="number" id="trackerPort" placeholder="Tracker Port" value="9000">
                <button class="btn-init" onclick="initializePeer()">ƒêƒÉng k√Ω</button>
            </div>

            <!-- Personal Info -->
            <div>
                <h2>üë§ My Info</h2>
                <div class="peer-info">
                    <p><strong>IP:</strong> <span id="myIpDisplay">-</span></p>
                    <p><strong>Port:</strong> <span id="myPortDisplay">-</span></p>
                    <p><strong>Status:</strong> <span class="status-indicator"></span><span id="statusDisplay">Offline</span></p>
                </div>
            </div>

            <!-- Online Peers -->
            <div>
                <h2>üåê Online Peers</h2>
                <div id="onlinePeersList" class="peer-list">
                    <div class="empty-state">No peers online</div>
                </div>
            </div>

            <!-- Connected Peers -->
            <div>
                <h2>‚úÖ Connected Peers</h2>
                <div id="connectedPeersList" class="connected-list">
                    <div class="empty-state">Not connected to any peer</div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <h2>üí¨ Chat Application</h2>

            <!-- Channel Tabs -->
            <div class="channel-tabs" id="channelTabs">
                <button class="channel-tab active" data-channel="broadcast" onclick="switchChannel('broadcast')">
                    üì¢ Broadcast
                    <span class="badge" id="badge-broadcast" style="display:none">0</span>
                </button>
                <button class="channel-tab" data-channel="a" onclick="switchChannel('a')">
                    # Channel A
                    <span class="badge" id="badge-a" style="display:none">0</span>
                </button>
                <button class="channel-tab" data-channel="b" onclick="switchChannel('b')">
                    # Channel B
                    <span class="badge" id="badge-b" style="display:none">0</span>
                </button>
                <button class="channel-tab" data-channel="c" onclick="switchChannel('c')">
                    # Channel C
                    <span class="badge" id="badge-c" style="display:none">0</span>
                </button>
                <button class="channel-tab" data-channel="d" onclick="switchChannel('d')">
                    # Channel D
                    <span class="badge" id="badge-d" style="display:none">0</span>
                </button>
            </div>

            <!-- Chat Area -->
            <div class="chat-area">
                <div class="messages" id="messagesArea">
                    <div class="empty-state">No messages yet. Start chatting!</div>
                </div>

                <!-- Input Area -->
                <div class="input-area">
                    <input type="text" id="messageInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                    <button class="btn-send" onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ========== Global state ==========
    let myIp = '';
    let myPort = 0;
    let trackerIp = '';
    let trackerPort = 0;
    let initialized = false;

    let onlinePeers = [];
    let connectedPeers = new Set();
    
    // Bi·∫øn l∆∞u k√™nh chat hi·ªán t·∫°i
    let currentChannel = 'broadcast';
    
    // Bi·∫øn l∆∞u tin nh·∫Øn
    // (Trong ·ª©ng d·ª•ng th·ª±c t·∫ø, b·∫°n n√™n l∆∞u theo t·ª´ng k√™nh)
    let messages = {};


    // ========== On page load ==========
    
    // ==========================================================
    // S·ª¨A L·ªñI 1: N√ÇNG C·∫§P H√ÄM `showNotification`
    // Thay th·∫ø `alert()` b·∫±ng h·ªá th·ªëng "toast" ƒë√£ c√≥ trong HTML
    // ==========================================================
    function showNotification(title, message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        if (!container) {
            console.warn("Notification container not found!");
            // Fallback v·ªÅ alert n·∫øu kh√¥ng t√¨m th·∫•y container
            alert(`${title}: ${message}`);
            return;
        }

        let icon = '‚ÑπÔ∏è'; // info
        if (type === 'success') icon = '‚úÖ';
        if (type === 'warning') icon = '‚ö†Ô∏è';
        if (type === 'error') icon = '‚ùå'; // D√πng 'error' cho nh·∫•t qu√°n

        const notif = document.createElement('div');
        notif.className = `notification ${type}`; // 'info', 'success', 'warning', 'error'

        notif.innerHTML = `
            <div class="notification-icon">${icon}</div>
            <div class="notification-content">
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            </div>
            <button class="notification-close" onclick="this.parentElement.remove()" style="background:none; border:none; font-size: 20px; cursor:pointer; color: #999;">&times;</button>
        `;

        container.appendChild(notif);

        // T·ª± ƒë·ªông x√≥a sau 5 gi√¢y (gi·ªëng animation trong CSS)
        setTimeout(() => {
            if (notif.parentNode === container) {
                // Th√™m animation m·ªù d·∫ßn n·∫øu mu·ªën
                notif.style.animation = "fadeOut 0.3s ease forwards";
                setTimeout(() => notif.remove(), 300);
            }
        }, 5000); // 5 gi√¢y
    }
    
    window.addEventListener('DOMContentLoaded', () => {
        autoDetectConfig();
        
        // ==========================================================
        // S·ª¨A L·ªñI 2: LOGIC T·∫¢I TRANG
        // Ch·ªâ kh√¥i ph·ª•c (restore) n·∫øu l√† 'reload', kh√¥ng ph·∫£i 'navigate'
        // ==========================================================
        
        // L·∫•y (c√°c) m·ª•c nh·∫≠p ƒëi·ªÅu h∆∞·ªõng
        const navEntries = performance.getEntriesByType("navigation");
        
        // L·∫•y lo·∫°i ƒëi·ªÅu h∆∞·ªõng (v√≠ d·ª•: 'navigate', 'reload', 'back_forward')
        const navType = navEntries.length > 0 ? navEntries[0].type : '';

        // Ch·ªâ kh√¥i ph·ª•c tr·∫°ng th√°i N·∫æU ƒë√¢y l√† m·ªôt 'reload' (F5 / T·∫£i l·∫°i)
        if (navType === 'reload') {
            console.log("Navigation type: RELOAD. Restoring state.");
            restorePeerState(); // T·∫£i t·ª´ localStorage
        } else {
            console.log("Navigation type: NAVIGATE (or other). Starting fresh.");
            // Kh√¥ng l√†m g√¨ c·∫£, ƒë·ªÉ cho ng∆∞·ªùi d√πng t·ª± initialize
            // (X√≥a tr·∫°ng th√°i c≈© n·∫øu c√≥, ƒë·ªÉ ƒë·∫£m b·∫£o s·∫°ch)
            localStorage.removeItem('peerState');
        }
    });

    function autoDetectConfig() {
        const hostname = window.location.hostname;
        const port = window.location.port;
        myIp = hostname;
        myPort = parseInt(port) || 80;
        document.getElementById('myIp').value = myIp;
        document.getElementById('myPort').value = myPort;
        document.getElementById('trackerIp').value = myIp;
    }

    // ========== LocalStorage Handling ==========
    function savePeerState() {
        const state = { 
            myIp, 
            myPort, 
            trackerIp, 
            trackerPort, 
            initialized,
            connectedPeers: Array.from(connectedPeers) };
        localStorage.setItem('peerState', JSON.stringify(state));
    }

    function restorePeerState() {
        const state = JSON.parse(localStorage.getItem('peerState') || 'null');
        if (state && state.initialized) {
            myIp = state.myIp;
            myPort = state.myPort;
            trackerIp = state.trackerIp;
            trackerPort = state.trackerPort;
            initialized = true;

            // üîß C·∫≠p nh·∫≠t l·∫°i input cho form
            document.getElementById('myIp').value = myIp;
            document.getElementById('myPort').value = myPort;
            document.getElementById('trackerIp').value = trackerIp;
            document.getElementById('trackerPort').value = trackerPort;
            connectedPeers = new Set(state.connectedPeers || []);

            updateUiAfterInit();

            // await syncWithTracker();
            updateOnlinePeersList();
            updateConnectedPeersList();

            showNotification('Restored', `Peer ${myIp}:${myPort} restored from local storage`, 'info');
            startSyncLoop();
        }
    }

    // ========== Initialize Peer ==========
    async function initializePeer() {
        if (initialized) {
            showNotification('Already initialized', 'Peer already registered.', 'info');
            return;
        }

        myIp = document.getElementById('myIp').value;
        myPort = parseInt(document.getElementById('myPort').value);
        trackerIp = document.getElementById('trackerIp').value;
        trackerPort = parseInt(document.getElementById('trackerPort').value);

        if (!myIp || !myPort || !trackerIp || !trackerPort) {
            showNotification('Error', 'Please fill all configuration fields', 'warning');
            return;
        }

        try {
            await registerToTracker();
            initialized = true;
            savePeerState(); // L∆∞u tr·∫°ng th√°i sau khi init th√†nh c√¥ng
            updateUiAfterInit();
            showNotification('Initialized', `Peer ${myIp}:${myPort} registered to tracker!`, 'success');
            startSyncLoop();
        } catch (err) {
            showNotification('Error', 'Failed to initialize: ' + err.message, 'error'); // D√πng 'error'
        }
    }

    function updateUiAfterInit() {
        document.getElementById('myIpDisplay').textContent = myIp;
        document.getElementById('myPortDisplay').textContent = myPort;
        document.getElementById('statusDisplay').textContent = 'Online';
        document.querySelector('.btn-init').disabled = true;
    }

    async function registerToTracker() {
        const url = `http://${trackerIp}:${trackerPort}/submit-info`;
        const body = JSON.stringify({ ip: myIp, port: myPort });
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body
        });
        if (!res.ok) {
            throw new Error(`Tracker returned ${res.status}`);
        }
        return res.json();
    }

    // ========== Tracker Sync ==========
    
    // ================== S·ª¨A ƒê·ªîI JAVASCRIPT ==================
    async function startSyncLoop() {
        // Thay ƒë·ªïi: G·ªôp getPeerList v√† getConnectionsList v√†o m·ªôt h√†m
        setInterval(syncWithTracker, 5000); // 5 gi√¢y
        syncWithTracker(); // Ch·∫°y l·∫ßn ƒë·∫ßu
    }

    /**
     * H√ÄM M·ªöI: ƒê·ªìng b·ªô h√≥a c·∫£ danh s√°ch peer v√† danh s√°ch k·∫øt n·ªëi
     */
    async function syncWithTracker() {
        if (!initialized) return;
        try {
            // Ch·∫°y c·∫£ hai y√™u c·∫ßu song song
            await Promise.all([
                getPeerList(),
                getConnectionsList()
            ]);
        } catch (err) {
            console.error("Sync error:", err);
            showNotification('Sync Error', 'Could not sync with tracker', 'warning');
        }
        
        // Ch·ªâ c·∫≠p nh·∫≠t UI sau khi c·∫£ hai ƒë√£ ho√†n t·∫•t
        updateOnlinePeersList();
        updateConnectedPeersList();
    }
    
    /**
     * H√ÄM M·ªöI: L·∫•y danh s√°ch k·∫øt n·ªëi t·ª´ Tracker
     * (Gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ Peer B kh√¥ng t·ª± c·∫≠p nh·∫≠t)
     */
    async function getConnectionsList() {
        const res = await fetch(`http://${trackerIp}:${trackerPort}/get-connections`);
        if (!res.ok) throw new Error("Failed to get connections");
        
        const data = await res.json();
        const connections = data.connected_peers || {};
        
        const myKey = `${myIp}:${myPort}`;
        const newConnectedPeers = new Set();
        
        // 1. L·∫•y nh·ªØng ng∆∞·ªùi M√Ä T√îI ƒë√£ k·∫øt n·ªëi
        (connections[myKey] || []).forEach(peer => {
            newConnectedPeers.add(`${peer.ip}:${peer.port}`);
        });
        
        // 2. L·∫•y nh·ªØng ng∆∞·ªùi ƒê√É K·∫æT N·ªêI V·ªöI T√îI (Gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ c·ªßa Peer B)
        for (const peerKey in connections) {
            if (peerKey === myKey) continue;
            const connectedToThem = connections[peerKey] || [];
            // N·∫øu peerKey (vd: Peer A) c√≥ k·∫øt n·ªëi ƒë·∫øn t√¥i (Peer B)
            if (connectedToThem.some(p => p.ip === myIp && p.port === myPort)) {
                newConnectedPeers.add(peerKey);
            }
        }
        
        // C·∫≠p nh·∫≠t state (ch·ªâ khi c√≥ thay ƒë·ªïi)
        if (newConnectedPeers.size !== connectedPeers.size || !([...newConnectedPeers].every(p => connectedPeers.has(p)))) {
            connectedPeers = newConnectedPeers;
        }
    }

    /**
     * C·∫≠p nh·∫≠t h√†m getPeerList (b·ªè g·ªçi update UI)
     */
    async function getPeerList() {
        // if (!initialized) return; // ƒê√£ check trong syncWithTracker
        try {
            const res = await fetch(`http://${trackerIp}:${trackerPort}/get-list`);
            const data = await res.json();
            onlinePeers = data.peers || [];
            // updateOnlinePeersList(); // B·ªè: syncWithTracker s·∫Ω g·ªçi
        } catch (err) {
            console.error(err);
            // C√≥ th·ªÉ hi·ªÉn th·ªã th√¥ng b√°o l·ªói
            // showNotification('Sync Error', 'Could not fetch peer list', 'warning');
        }
    }
    // ========================================================


    // ========== UI Rendering ==========
    function updateOnlinePeersList() {
        const list = document.getElementById('onlinePeersList');
        if (onlinePeers.length === 0) {
            list.innerHTML = '<div class="empty-state">No peers online</div>';
            return;
        }

        list.innerHTML = '';
        onlinePeers.forEach(peer => {
            const key = `${peer.ip}:${peer.port}`;
            const isMe = (peer.port === myPort && peer.ip === myIp); // Ki·ªÉm tra c·∫£ IP v√† Port
            const isConnected = connectedPeers.has(key);

            const item = document.createElement('div');
            item.className = 'peer-item';
            item.innerHTML = `
                <div class="peer-item-info">
                    <div class="peer-address">${key} ${isMe ? '<strong>(You)</strong>' : ''}</div>
                    <div class="peer-status">${isMe ? 'üü¢ Online' : 'üü¢ Available'}</div>
                </div>
                <button class="btn btn-connect"
                    ${isMe || isConnected ? 'disabled' : ''}
                    onclick="connectToPeer('${peer.ip}', ${peer.port})">
                    ${isMe ? 'Me' : isConnected ? 'Connected' : 'Connect'}
                </button>`;
            list.appendChild(item);
        });
    }

    // ========== Connection Logic ==========
    async function connectToPeer(ip, port) {
        const key = `${ip}:${port}`;
        if (connectedPeers.has(key)) return;

        try {
            // 1Ô∏è‚É£ G·ª≠i y√™u c·∫ßu ƒë·∫øn tracker (t√πy ch·ªçn, ch·ªâ ƒë·ªÉ log)
            await fetch(`http://${trackerIp}:${trackerPort}/connect-peer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    from: { ip: myIp, port: myPort },
                    to: { ip, port }
                })
            });

            // 2Ô∏è‚É£ G·ª≠i y√™u c·∫ßu tr·ª±c ti·∫øp ƒë·∫øn peer B
            await fetch(`http://${ip}:${port}/accept-connection`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ from: { ip: myIp, port: myPort } })
            });

            // 3Ô∏è‚É£ C·∫≠p nh·∫≠t UI
            connectedPeers.add(key);
            savePeerState();
            updateOnlinePeersList();
            updateConnectedPeersList();
            showNotification('Connected', `Connected to ${key}`, 'success');
            
            // 4Ô∏è‚É£ T·ª∞ ƒê·ªòNG T·∫†O V√Ä CHUY·ªÇN SANG K√äNH 1:1
            createOrSwitchToP2PChannel(key, ip, port);
            
        } catch (err) {
            showNotification('Error', 'Failed to connect: ' + err.message, 'error'); // D√πng 'error'
        }
    }

    // ================== S·ª¨A ƒê·ªîI JAVASCRIPT ==================
    /**
     * C·∫≠p nh·∫≠t h√†m updateConnectedPeersList
     * (Bi·∫øn danh s√°ch th√†nh c√°c n√∫t b·∫•m)
     */
    function updateConnectedPeersList() {
        const list = document.getElementById('connectedPeersList');
        if (connectedPeers.size === 0) {
            list.innerHTML = '<div class="empty-state">Not connected to any peer</div>';
            return;
        }
        list.innerHTML = '';
        Array.from(connectedPeers).forEach(key => { 
            const [ip, port] = key.split(':');
            
            const button = document.createElement('button');
            button.className = 'connected-item-button'; // Class CSS m·ªõi
            button.innerHTML = `üí¨ ${key}`; // Th√™m icon chat
            // G√°n s·ª± ki·ªán click ƒë·ªÉ m·ªü k√™nh 1:1
            button.onclick = () => createOrSwitchToP2PChannel(key, ip, port);
            
            list.appendChild(button);
        });
    }
    // ========================================================


    // ========== Chat Logic (Placeholder) ==========
    
    // ================== S·ª¨A ƒê·ªîI JAVASCRIPT ==================
    /**
     * H√ÄM M·ªöI: T·∫°o v√† chuy·ªÉn sang k√™nh 1:1
     */
    function createOrSwitchToP2PChannel(key, ip, port) {
        const channelId = `p2p_${key}`; // ID duy nh·∫•t, vd: p2p_127.0.0.1:8000
        const tabsContainer = document.getElementById('channelTabs');
        
        let p2pTab = document.querySelector(`.channel-tab[data-channel="${channelId}"]`);
        
        if (!p2pTab) {
            // T·∫°o tab m·ªõi n·∫øu ch∆∞a c√≥
            p2pTab = document.createElement('button');
            p2pTab.className = 'channel-tab p2p'; // Class m·ªõi cho P2P
            p2pTab.dataset.channel = channelId;
            p2pTab.textContent = `üë§ ${key}`; // Icon 1:1
            p2pTab.onclick = () => switchChannel(channelId);
            
            // Th√™m v√†o cu·ªëi danh s√°ch tab
            tabsContainer.appendChild(p2pTab);
        }
        
        // T·ª± ƒë·ªông chuy·ªÉn sang tab n√†y
        // (H√†m switchChannel s·∫Ω t·ª± b·ªè active ·ªü 'broadcast')
        switchChannel(channelId);
    }
    // ========================================================


    function switchChannel(channelId) {
        // B·ªè active ·ªü tab c≈©
        document.querySelector('.channel-tab.active')?.classList.remove('active');
        
        // Active tab m·ªõi
        const newTab = document.querySelector(`.channel-tab[data-channel="${channelId}"]`);
        newTab?.classList.add('active');
        
        // X√≥a badge (n·∫øu c√≥)
        const badge = document.getElementById(`badge-${channelId}`);
        if(badge) {
            badge.style.display = 'none';
            badge.textContent = '0';
        }

        currentChannel = channelId;
        renderMessages(currentChannel);
        
        // (Logic tham gia k√™nh n·∫øu ch∆∞a tham gia)
    }
    
    function renderMessages(channelId) {
        const messagesArea = document.getElementById('messagesArea');
        messagesArea.innerHTML = ''; // X√≥a tin nh·∫Øn c≈©
        
        const channelMessages = messages[channelId] || [];
        
        if (channelMessages.length === 0) {
            messagesArea.innerHTML = '<div class="empty-state">No messages in this channel yet.</div>';
            return;
        }
        
        channelMessages.forEach(msg => {
            appendMessage(msg.sender, msg.content, msg.type, msg.time);
        });
    }
    
    function appendMessage(sender, content, type, timeStr) {
        const messagesArea = document.getElementById('messagesArea');
        
        // X√≥a empty state n·∫øu l√† tin nh·∫Øn ƒë·∫ßu ti√™n
        const emptyState = messagesArea.querySelector('.empty-state');
        if (emptyState) emptyState.remove();

        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${type}`; // 'sent' ho·∫∑c 'received'
        
        const time = timeStr || new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

        msgDiv.innerHTML = `
            <div class="sender">${sender}</div>
            <div class="content">${content}</div>
            <div class="time">${time}</div>
        `;
        messagesArea.appendChild(msgDiv);
        
        // Cu·ªôn xu·ªëng tin nh·∫Øn m·ªõi nh·∫•t
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    function sendMessage() {
        if (!initialized) {
            showNotification('Error', 'Please initialize the peer first.', 'warning');
            return;
        }
        
        const input = document.getElementById('messageInput');
        const messageContent = input.value.trim();
        
        if (messageContent === '') return;
        
        const senderId = `${myIp}:${myPort}`;
        const messageData = {
            sender: senderId,
            content: messageContent,
            type: 'sent', // ƒê√¢y l√† tin nh·∫Øn 'g·ª≠i'
            time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
        };
        
        // 1. Th√™m v√†o UI
        appendMessage(senderId + " (You)", messageContent, 'sent', messageData.time);
        
        // 2. L∆∞u v√†o CSDL local
        if (!messages[currentChannel]) {
            messages[currentChannel] = [];
        }
        messages[currentChannel].push(messageData);
        
        // 3. G·ª≠i broadcast (ho·∫∑c P2P)
        broadcastMessage(currentChannel, messageContent);

        input.value = ''; // X√≥a input
    }
    
    async function broadcastMessage(channel, messageContent) {
        // (Trong ·ª©ng d·ª•ng th·ª±c t·∫ø, b·∫°n s·∫Ω g·ª≠i ƒë·∫øn t·∫•t c·∫£ 'connectedPeers')
        console.log(`Broadcasting to ${channel}: ${messageContent}`);
        
        // V√≠ d·ª• g·ª≠i qua tracker (n·∫øu tracker h·ªó tr·ª£)
        // await fetch(`http://${trackerIp}:${trackerPort}/broadcast-peer`, {
        //     method: 'POST',
        //     headers: { 'Content-Type': 'application/json' },
        //     body: JSON.stringify({
        //         from: { ip: myIp, port: myPort },
        //         channel: channel,
        //         message: messageContent
        //     })
        // });
        
        // Ho·∫∑c g·ª≠i tr·ª±c ti·∫øp ƒë·∫øn t·ª´ng peer
        connectedPeers.forEach(peerKey => {
            const [ip, port] = peerKey.split(':');
            sendDirectMessage(ip, port, channel, messageContent);
        });
    }

    async function sendDirectMessage(ip, port, channel, messageContent) {
        try {
            await fetch(`http://${ip}:${port}/receive-message`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    from: `${myIp}:${myPort}`,
                    channel: channel,
                    message: messageContent
                })
            });
        } catch (err) {
            console.error(`Failed to send message to ${ip}:${port}`, err);
            showNotification('Send Error', `Could not send message to ${ip}:${port}`, 'error');
        }
    }

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }
    
    // (B·∫°n c·∫ßn th√™m m·ªôt route tr√™n Peer server ƒë·ªÉ nh·∫≠n tin nh·∫Øn, 
    // v√≠ d·ª• /receive-message, v√† sau ƒë√≥ g·ªçi 'appendMessage' v·ªõi type 'received')

</script>

</body>
</html>